% -*- Mode: Prolog -*-

:- use_module(lexicon, [macro_expand/2,get_item_semantics/5]).
:- use_module(heap, [empty_heap/1,add_to_heap/4,get_from_heap/4]).
:- use_module(prob_lex, [list_atom_term/2,list_atom_term/3,remove_brackets/2]).
:- use_module(sem_utils, [substitute_sem/3,reduce_sem/2]).
:- use_module(latex, [latex_proof/2,latex_header/1,latex_header/2,latex_tail/1,latex_semantics/3]).
:- use_module(options, [create_options/0,get_option/2,option_true/1]).
:- use_module(ordset, [ord_subtract/3, ord_insert/3, ord_subset/2, ord_key_insert/4, ord_select/3,ord_delete/3]).
:- use_module(library(pce)).
:- use_module(library(pce_util)).

:- dynamic sentence_length/1, total_formulas/1, unparsed/3, parsed/2.
:- dynamic word/3, word/4, word/5, stored/6, max_queue_size/1, grail_heap/2, justify/2.
:- dynamic crosses/3, crosses/4, current_sentence/1.
:- dynamic translate_form/2, translate_sem/2, state/2.

:- compile('~/checkout/Grail/grammars/big_french_drt.pl').

:- dynamic '$SOLUTION'/1.
:- dynamic verbose/0, interactive/0.

:- create_options.

display_unreduced_semantics(no).

default_depth_limit(25000).
output_natural_deduction_proofs(true).

combine_probability(Prob0, Prob1, J, K, _R, Prob) :-
	crosses(J, K, Cross),
	Prob is Prob0 + Prob1 + Cross.

% = Chart parse library.
%
% This library contains code adapted from the following paper:
%
% Stuart M. Shieber, Yves Schabes and Fernando C. N. Pereira (1995)
% `Principles and Implementation of Deductive Parsing', Journal of
% Logic Programming 24(1-2):3-36
%
% though with some notable additions and modifications.

% Chart items are of the form
%
%   item(Formula, Left, Right, Data)
%
% where Formula is a multimodal formula, Left and Right are
% string positions representing the leftmost and the
% rightmost part of the string which was recongized as
% being of type Formula.
%
% Item data is a structure containing the following information.
%
%   data(Pros, Sem, Prob, A, B, C)
%
% where Pros is the prosodic structure (representing the
% words of the string in tree form), Sem is the semantics
% of the Formula, Prob is its probabiblity,

% = export chart contents to the file 'stored.txt'

export :-
	shell('rm stored.txt', _),
	tell('stored.txt'),
	listing(stored),
	listing(justification),
	told.

% = parse all sentences.

chart_parse_all :-
	default_depth_limit(DLimit),
	chart_parse_all(1, DLimit).

% = parse all sentences with a given depth limit DL

chart_parse_all_dl(DL) :-
	chart_parse_all(1, DL).

% = parse all sentences starting with SentNo

chart_parse_all(SentNo) :-
	default_depth_limit(DLimit),
	chart_parse_all(SentNo, DLimit).

chart_parse_all(SentNo, DL) :-
	shell('rm chart*.dot', _),
	retractall(unparsed(_,_,_)),
	new_output_file(grail_log, log),
	new_output_file(unparsed, unparsed),
	new_output_file(parse_logs, plog),
	new_output_file('proof.tex', proof),
	new_output_file('proofs.pl', pl_proof),
	set_global_counter('$CHART_CURRENT', 0),
	set_global_counter('$CHART_FAIL', 0),
	set_global_counter('$CHART_LIMIT', 0),
	set_global_counter('$CHART_ALL', 0),
	print_grail_semantics_header,
	chart_parse_all0(SentNo, DL),
	/* cleanup after failure-driven loop has parsed all sentences */
	'$CHART_ALL'(ALL),
	'$CHART_FAIL'(FAIL),
	'$CHART_LIMIT'(LIMIT),
	retractall('$CHART_ALL'(_)),
	retractall('$CHART_FAIL'(_)),
	retractall('$CHART_LIMIT'(_)),
	Success is (ALL - FAIL) - LIMIT,
	SPercentage is (100*Success)/ALL,
	FPercentage is (100*FAIL)/ALL,
	LPercentage is (100*LIMIT)/ALL,
	format('Finished parsing~n~w total sentences~n~w sentences succeeded (~w %)~n~w sentences failed (~w %)~n~w resource limits (~w %)~n', [ALL,Success,SPercentage,FAIL,FPercentage,LIMIT,LPercentage]),
	print_grail_semantics_tail,
	close(unparsed),
	close(proof),
	close(pl_proof),
	close(plog),
	close(log).

chart_parse_all0(N, DL) :-
	clause(user:sent(N0,_),_),
    (
        /* fail for sentence numbers smaller than N */
        N0 >= N
    ->
        increase_global_counter('$CHART_ALL'),
        set_global_counter('$CHART_CURRENT', N0)
    ),
	format('~nStarting: ~w~n', [N0]),
	update_crossing(N0),
	statistics(process_cputime, CPU0),
	statistics(inferences, Inferences0),
    (
	call_with_depth_limit(user:sent(N0, Result), DL, DepthLimit)
    ->
        (
	   DepthLimit = depth_limit_exceeded
	->
	   try_recover_chart_semantics(N0, DL, Inferences0, CPU0)
	 ;
	   print_statistics('S', N0, DepthLimit, Inferences0, CPU0),
	   print_grail_semantics(Result),
	   assert(parsed(N0, Result)),
	   format('~nSuccess: ~w (~w)~n', [N0,DepthLimit])
	)
    ;
        print_statistics('F', N0, DL, Inferences0, CPU0),
	print_chart(N0),
	assert('unparsed'(N0,Length,fail)),
        portray_clause(unparsed, unparsed(N0,Length,fail)), 
        increase_global_counter('$CHART_FAIL'),
	format('~nFailure: ~w~n', [N0])
    ),
        fail.
chart_parse_all0(_, _).

sentence(S, Sem) :-
	update_crossing(S),
	user:sent(S, Sem).

update_crossing(S) :-
	retractall(current_sentence(_)),
	assert(current_sentence(S)),
	retractall(crosses(_,_,_)),
	% set three-argument crosses to current sentence
	assert((crosses(X,Y,Z) :- crosses(S,X,Y,Z), !)),
	% default to no crosses
	assertz(crosses(_,_,0)),
	retractall(word(_,_,_)),
	assert((word(A,B,C) :- word(S,A,B,C))).

print_statistics(State, N0, DepthLimit, Inferences0, CPU0) :-
	   statistics(inferences, Inferences1),
	   statistics(process_cputime, CPU1),
	   CPU is CPU1 - CPU0,
	   Inferences is Inferences1 - Inferences0,
	   sentence_length(Length),
	   total_formulas(TotalForms),
	   max_queue_size(MaxQ),
	   format(plog, '~w\t~w\t~w\t~w\t~w\t~2f\t~w\t~w~n', [N0, State, Length, TotalForms, DepthLimit, CPU, Inferences, MaxQ]).

try_recover_chart_semantics(N0, DL, Inferences, CPU) :-
	final_item(Goal, Index, Sem),
	item_in_chart(Goal, Index),
	compute_proof(Index),
	!,
       	increase_global_counter('$SOLUTION'),
	assert(parsed(N0, Sem)),
	print_grail_semantics(Sem),
	format('~nSuccess: ~w (MAX)~n', [N0]),
        print_statistics('S', N0, DL, Inferences, CPU).
try_recover_chart_semantics(N0, DL, Inferences, CPU) :-
	increase_global_counter('$CHART_LIMIT'),
	assert('unparsed'(N0,Length,depth_limit)),
        portray_clause(unparsed, unparsed(N0,Length,depth_limit)),
	format('~nDepth limit exceeded: ~w~n', [N0]),
        print_statistics('L', N0, DL, Inferences, CPU).

% = print_chart(+SentNo)
%
% output the chart contexts to a GraphViz file

print_chart(SentNo) :-
	concat_atom(['chart',SentNo,'.dot'], FileName),
	open(FileName, write, Stream),
	print_chart1(Stream),
	close(Stream).
print_chart1(Stream) :-
	format(Stream, 'digraph "chart" {~n', []),
	stored(_, _, I, J, F, _),
	format(Stream, '~w -> ~w [label="~p"]~n', [I,J,F]),
	fail.
print_chart1(Stream) :-
	format(Stream, '}~n', []).

% = chart_to_heap(Ex)
%
% conver chart contents to a heap to be passed to Grail with
% the goal of handing an incomplete parse over to Grail.
% TODO: complete

chart_to_heap(Ex) :-
	findall(P-X, chart_prob(P,X), List),
	empty_heap(Heap0),
	add_list_to_heap(List, Heap0, Heap),
	assert(grail_heap(Ex, Heap)).

add_list_to_heap([], Heap, Heap).
add_list_to_heap([P-X|Xs], Heap0, Heap) :-
	add_to_heap(Heap0, P, X, Heap1),
	add_list_to_heap(Xs, Heap1, Heap).

parse_best_span(N0, I, J) :-
	parse_best_span(I, J, L, []),
	format('~w ~w', [N0, L]).

chart_prob(D-Prob,t(I,J,Atom,F,Sem)) :-
	stored(_, _, I, J, F, data(Pros, Sem, Prob, [], [], [])),
	D is J - I,
	pros_to_atom(Pros, Atom).

pros_to_atom(Pros, Atom) :-
	pros_to_list(Pros, List, []),
	concat_atom(List, '_', Atom).

pros_to_list(p(_,P1,P2), L0, L) :-
	!,
	pros_to_list(P1, L0, L1),
	pros_to_list(P2, L1, L).
pros_to_list(P, [P|L], L).

% = startsymbol(+Start, +Semantics)
%
% true if Start is a valid category for spanning the entire chart.
% Semantics is the semantic term for existantial closure and other "final" operations to produce proper DRSs

startsymbol(lit(txt), lambda(X,X)).
startsymbol(lit(s), lambda(S,merge(drs([event(E)],[]),appl(S,E)))).
startsymbol(lit(s(_)), lambda(S,merge(drs([event(E)],[]),appl(S,E)))).
startsymbol(lit(np(_,_,_)), lambda(P,appl(P,lambda(_V,drs([],[]))))).
startsymbol(lit(n), lambda(N,merge(drs([variable(X)],[]),appl(N,X)))).
startsymbol(dl(0,lit(np(_,_,_)),lit(s(_))), lambda(VP,merge(drs([event(E),variable(X)],[appl(generic,X)]),appl(appl(VP,lambda(P,appl(P,X))),E)))).
startsymbol(dl(0,lit(n),lit(n)), lambda(ADJ,merge(drs([variable(X)],[]),appl(appl(ADJ,lambda(_,drs([],[]))),X)))).
startsymbol(dr(0,lit(s),lit(s)), lambda(ADV,merge(drs([event(E)],[bool(E,=,'event?')]),appl(appl(ADV,lambda(_,drs([],[]))),E)))).
startsymbol(dr(0,lit(s(_)),lit(s(_))), lambda(ADV,merge(drs([event(E)],[bool(E,=,'event?')]),appl(appl(ADV,lambda(_,drs([],[]))),E)))).
startsymbol(lit(let), lambda(_,drs([],[]))).

grail_chart(L) :-	
	print_grail_semantics_header,
	/* separate words from forula assignments */
	split_a_b_c_ds(L, Ws0, POSs0, Lemmas0, Fs0),
	/* turn POS tags from atoms into terms */
	list_atom_term(POSs0, POSs),
	list_atom_term(Lemmas0, Lemmas),
	/* separate formulas from probabilities */
	list_atom_term(Fs0, FPs, []),
	/* compute sentence string */
	remove_brackets(Ws0, Ws),
	init_chart,
	empty_heap(Heap),
	create_chart(Ws, POSs, Lemmas, FPs, 0, Heap, 0, _MaxVar, SemInfo, [], Chart, []),
    (
	chart_parse(Chart, Semantics0)
    ->
        chart_semantics(SemInfo, Semantics0, Semantics),
        print_grail_semantics(Semantics),
        print_grail_semantics_tail
    ;
        true
    ),
        /* output final chart for debugging */
        export,
	finished_dialog,
	halt.

chart_semantics(SemInfo, Semantics0, Semantics) :-
	compute_semantics(SemInfo, Subst),
        substitute_sem(Subst, Semantics0, Semantics).	

compute_semantics([], []).
compute_semantics([IN-t(W,PosTT,Lemma,F)|Rest0], [IN-Sem|Rest]) :-
	get_item_semantics(W, PosTT, Lemma, F, Sem),
	compute_semantics(Rest0, Rest).

print_grail_semantics_header :-
	open_semantics_files,
	get_option(paper_size, PaperSize),
	latex_header(sem, PaperSize).

print_grail_semantics(Sem) :-
	numbervars(Sem, 0, _),
	reduce_sem(Sem, RSem),
	format('~nSemantics   : ~p~n', [Sem]),
	format('Reduced Sem : ~p~n', [RSem]),
	format(log, '~n% = Semantics~2n ~W~2n', [Sem,[numbervars(true),quoted(true)]]),
	format(log, '% = Reduced Semantics~2n~W~2n', [RSem,[numbervars(true),quoted(true)]]),
	format(sem_pl, '~n% = Semantics~2n ~W.~2n', [Sem,[numbervars(true),quoted(true)]]),
	format(sem_pl, '% = Reduced Semantics~2n~W.~2n', [RSem,[numbervars(true),quoted(true)]]),
	format(sem, '~n\\begin{multline}~n', []),
   (
        display_unreduced_semantics(yes)
   ->
	latex_semantics(Sem, Formula, sem),
	format(sem, '\\rightarrow_{\\beta}\\\\ ', [])
   ;
        true
   ),
	latex_semantics(RSem, Formula, sem),
	format(sem, '~n\\end{multline}~2n', []).

print_grail_semantics_tail :-
	latex_tail(sem),
	close(sem),
	pdflatex_semantics.
	
add_heap_to_chart(H0) -->
	{get_from_heap(H0, _Key, Datum, H)},
	!,
	[Datum],
	add_heap_to_chart(H).
add_heap_to_chart(_) -->
	[].

% create_chart(+WordList, +POSList, +LemmaList, +FormulaProbList, +WordNo, Heap)

create_chart([], [], [], [], N, H, V, V, S, S) -->
	{retractall(sentence_length(_)),
	 assert(sentence_length(N))},
	add_heap_to_chart(H).
create_chart([W|Ws], [P|Ps], [L|Ls], [FP|FPs], N0, H0, V0, V, S0, S) -->
	{ N is N0 + 1,
	  assert(word(W,P,L,N0,N)),
	  verify_word(W,N0,N)},
	append_item_and_update_heap(FP, W, P, L, N0, N, V0, V1, S0, S1, H0, H),
	create_chart(Ws, Ps, Ls, FPs, N, H, V1, V, S1, S).


prob_parse(List, Result) :-
	check_log_stream,
	init_chart,
	empty_heap(Heap),
	list_to_chart(List, 0, Heap, Chart, [], 0, _V, SemInfo, []),
   (
        interactive
   ->
        interactive_parse(Chart, Result0)
   ;
	chart_parse(Chart, Result0)
   ),
	chart_semantics(SemInfo, Result0, Result).
   
verify_word(W, N0, N) :-
	word(W1, N0, N),
	!,
    (
        W = W1
    ->
        true
    ;
        format('Alignment error: ~w-~w (~w-~w)~n', [W, W1, N0, N])
    ).
verify_word(_, _ , _).

lemma_sequence([], N, N).
lemma_sequence([L|Ls], N0, N) :-
	word(_, _, L, N0, N1),
	lemma_sequence(Ls, N1, N).


list_to_chart([], N, H, As0, As, V, V, S, S) :-
	retractall(sentence_length(_)),
	assert(sentence_length(N)),
	add_heap_to_chart(H, As0, As).
list_to_chart([si(W,Pos,Lemma,FPs)|Ws], N0, H0, As0, As, V0, V, S0, S) :-
	N1 is N0 + 1,
	assert(word(W,Pos,Lemma,N0,N1)),
	append_item_and_update_heap(FPs, W, Pos, Lemma, N0, N1, V0, V1, S0, S1, H0, H, As0, As1),
	list_to_chart(Ws, N1, H, As1, As, V1, V, S1, S).

get_semantics(item(_, _, _, Data), Sem) :-
	get_data_semantics(Data, Sem).

get_data_semantics(data(_, Sem, _, _, _, _), Sem).

get_weight(item(_, _, _, Data), Weight) :-
	get_data_weight(Data, Weight).

get_data_weight(data(_, _, Weight, _, _, _), Weight).

is_punct(ponct).
is_punct(pun).
is_punct(ponct-pun).

boring([]).
boring([Item-_|FPs]) :-
	boring_item(Item),
	!,
	boring(FPs).
boring([Item,_|FPs]) :-
	boring_item(Item),
	boring(FPs).

boring_item(let).
boring_item(dl(0,_,txt)).
boring_item(dl(0,_,lit(txt))).

append_items([], _, _, _, _, _, IN, IN, S, S) -->
	[].
append_items([F0-P|FPs], W, Pos, Lemma, N0, N1, IN0, IN, S0, S) -->
	!,
	{create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, IN1, S0, S1, Item)},
	[Item],
	append_items(FPs, W, Pos, Lemma, N0, N1, IN1, IN, S1, S).
append_items([F0,P|FPs], W, Pos, Lemma, N0, N1, IN0, IN, S0, S) -->
	{create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, S0, S1, Item),
	 IN1 is IN0 + 1},
	[Item],
	append_items(FPs, W, Pos, Lemma, N0, N1, IN1, IN, S1, S).

append_item_and_update_heap([], _, _, _, _, _, _, S, S, H, H) -->
	[].
append_item_and_update_heap([F0-P|FPs], W, Pos, Lemma, N0, N1, IN0, IN, S0, S, H0, H) -->
	!,
	{create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, S0, S1, Item),
	 IN1 is IN0 + 1},
	[Item],
	{update_heap(FPs, P, W, Pos, Lemma, N0, N1, IN1, IN, S1, S, H0, H)}.
append_item_and_update_heap([F0,P|FPs], W, Pos, Lemma, N0, N1, IN0, IN, S0, S, H0, H) -->
	{create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, S0, S1, Item),
	 IN1 is IN0 + 1},
	[Item],
	{update_heap(FPs, P, W, Pos, Lemma, N0, N1, IN1, IN, S1, S, H0, H)}.

enrich_formula(par, _, dr(0,lit(pp(par)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(par, _, dr(0,lit(pp(par)),lit(n))) :-
	!.
enrich_formula(pour, _, dr(0,lit(pp(pour)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(pour, _, dr(0,lit(pp(pour)),lit(n))) :-
	!.
enrich_formula(contre, _, dr(0,lit(pp(contre)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(contre, _, dr(0,lit(pp(contre)),lit(n))) :-
	!.
enrich_formula(sous, _, dr(0,lit(pp(sous)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(sous, _, dr(0,lit(pp(sous)),lit(n))) :-
	!.
enrich_formula(sur, _, dr(0,lit(pp(sur)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(sur, _, dr(0,lit(pp(sur)),lit(n))) :-
	!.
enrich_formula(en, _, dr(0,lit(pp(en)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(en, _, dr(0,lit(pp(en)),lit(n))) :-
	!.
enrich_formula(de, _, dr(0,lit(pp(de)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(de, _, dr(0,lit(pp(de)),lit(n))) :-
	!.
enrich_formula(avant, _, dr(0,lit(pp(avant)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(avant, _, dr(0,lit(pp(avant)),lit(n))) :-
	!.
enrich_formula(après, _, dr(0,lit(pp(après)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(après, _, dr(0,lit(pp(après)),lit(n))) :-
	!.
enrich_formula(L, _, dr(0,lit(pp(L)),lit(np(acc,_,_)))) :-
	!.
enrich_formula(L, _, dr(0,lit(pp(L)),lit(n))) :-
	!.
enrich_formula(_, _, _).

correct_formula(ver:impe, dr(0, lit(s(S)),lit(np(nom,A,B))), dr(0, lit(s(S)), lit(np(acc,A,B)))) :-
	!.
correct_formula(ver:impe, dr(0, dr(0, lit(s(S)),lit(np(nom,A,B))), lit(pp(P))), dr(0, dr(0, lit(s(S)), lit(np(acc,A,B))), lit(pp(P)))) :-
	!.
correct_formula(ver:impe, dr(0, dr(0, lit(s(S)), lit(s(Q))), lit(np(nom,A,B))), dr(0, dr(0, lit(s(S)), lit(s(Q))), lit(np(acc,A,B)))) :-
	!.
correct_formula(_, F, F).

update_heap([], _, _, _, _, _, _, IN, IN, S, S, H, H).
update_heap([F0-P|FPs], PMax, W, Pos, Lemma, N0, N1, IN0, IN, S0, S, H0, H) :-
	!,
	create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, S0, S1, Item),
	IN1 is IN0 + 1,
	Key is PMax/P,
	add_to_heap(H0, Key, Item, H1),
	update_heap(FPs, PMax, W, Pos, Lemma, N0, N1, IN1, IN, S1, S, H1, H).
update_heap([F0,P|FPs], PMax, W, Pos, Lemma, N0, N1, IN0, IN, S0, S, H0, H) :-
	create_item(F0, P, W, Pos, Lemma, N0, N1, IN0, S0, S1, Item),
	IN1 is IN0 + 1,
	Key is PMax/P,
	add_to_heap(H0, Key, Item, H1),
	update_heap(FPs, PMax, W, Pos, Lemma, N0, N1, IN1, IN, S1, S, H1, H).

create_item(F0, P, W, Pos, Lemma, N0, N1, IN, [IN-t(W,PosTT,Lemma,F)|Ss], Ss, item(F, N0, N1, Data)) :-
	macro_expand(F0, F1),
	get_pos_tt(Pos, PosTT),
	enrich_formula(Lemma, PosTT, F1),
	correct_formula(PosTT, F1, F),
	create_data(W, F, P, '$VAR'(IN), N0, N1, Data).


get_pos_tt(Pos, PosTT) :-
      (
         Pos = _Melt0-Pos0:Sub
      ->
         PosTT = Pos0:Sub
      ;
         Pos = _Melt1-PosTT
      ->
         true
      ;
         PosTT = Pos
      ).

% = 

chart_parse(Axioms, Sem) :-
	init_agenda(Axioms, Agenda),
    (
        /* succeed for empty sentences (eg. interpunction only) */
        Agenda = queue(0,0)
    ->
        Sem = drs([],[])
    ;
	exhaust(Agenda),
	check_solution(Sem)
    ).

interactive_parse([], drs([],[])).
interactive_parse([A|As], Sem) :-
	add_axioms_to_chart([A|As], 0, N, Active),
	interactive_parse1(Active, N),
	check_solution(Sem).

interactive_parse1(Active0, N0) :-
    (
        Active0 = [_]
    ->
        true
    ;
        nl,
        portray_active(Active0),
	interactive_rule(Active0, Active, N0, N),
	interactive_parse1(Active, N)
    ).

portray_active([]).
portray_active([A|As]) :-
	stored(A,_B,C,D,E,data(Pros,_,W,L1,L2,L3)),
	!,
    (
        L1 = [], L2 = [], L3 = []
    ->
     	format('~t~w~3| ~t~w~3+-~w~t~3+~t~p~3+ ~p~t~36+ ~p~n', [A,C,D,W,E,Pros])
    ;
	format('~t~w~3| ~t~w~3+-~w~t~3+~t~p~3+ ~p~t~36+ ~p ~p ~p ~p~n', [A,C,D,W,E,Pros,L1,L2,L3])
     ),
	portray_active(As).

portray_chart(N) :-
	findall(stored(A,B,C,D,E,F), stored(A,B,C,D,E,F), List),
	portray_chart(List, 0, N).

interactive_rule(Active0, Active, N0, N) :-
	read_potential_trigger(_Trigger, Active0, Active1, Consequences),
	length(Consequences, L),
   (
        L = 1
   ->
        /* single rule application possible */
        Consequences = [_-(Item-Just)]
   ;
        /* multiple rules possible, ask user */
	portray_numbered_list(Consequences, 0),
	read_integer(Cnsq, L),
	nth0(Cnsq, Consequences, _-(Item-Just))
   ),
	apply_rule(Item, Just, Active1, Active, N0, N).

apply_rule(Item, Just, Active0, Active, N0, N) :-
	Just =.. [R|Args0],
	sort(Args0,Args),
	subtract_premisses(R, Args, Active0, Active1),
	ord_insert(Active1, N0, Active),
	N is N0 + 1,
	add_item_to_agenda(Item, Just, queue(N0,N0), _).


subtract_premisses(e_start, [A,B], Active0, Active) :-
	!,
    (
	stored(A, _, _, _, dr(0,_,dr(0,_,dia(Ind,box(Ind,_)))), _)
    ->
        ord_delete(Active0, B, Active)
    ;
        ord_delete(Active0, A, Active)
    ).
subtract_premisses(_, Ps, As0, As) :-
	ord_subtract(As0, Ps, As).

portray_numbered_list([], _).
portray_numbered_list([A|As], N0) :-
	format('~w. ~p~n', [N0,A]),
	N is N0 + 1,
	portray_numbered_list(As, N).

read_potential_trigger(Input, Active0, Active, Consequences) :-
	read_integer_from_list(Input0, Active0, Active1),
	find_all_consequences1(Input0, Consequences0, Active0),
    (
        Consequences0 = []
    ->
        format('No rule application possible, select another trigger!~n', []),
        read_potential_trigger(Input, Active0, Active, Consequences)
    ;
        Input = Input0,
        Active = Active1,
        Consequences = Consequences0
    ).
	
read_integer_from_list(Input, List0, List) :-
	robust_read(Input0),
    (
        integer(Input0),
        select(Input0, List0, List)
    ->
        Input = Input0
    ;
        Input0 = a
    ->
        format('Aborted!~n', []),
        fail
    ;
        Input0 = abort
    ->
        format('Aborted!~n', []),
        fail
    ;
        format('Input an integer from ~w (or type "a." to abort)~n', [List0]),
        read_integer_from_list(Input, List0, List)
    ).
    
read_integer(Input, N) :-
	robust_read(Input0),
    (
	integer(Input0),
        Input0 >= 0,
        Input0 =< N
    ->
        Input = Input0
    ;
        write('Input an integer between 0 and ~w', [N]),
        read_integer(Input, N)
    ).

robust_read(Input) :-
	catch(read(Input), E, print_message(error, E)),
    (
        var(Input)
    ->
        robust_read(Input)
    ;
        true
    ).
	
check_solution(Sem) :-
	final_item(Goal, Index, Sem),
	item_in_chart(Goal, Index),
	compute_proof(Index),
       	increase_global_counter('$SOLUTION').

init_agenda(Axioms, Agenda) :-
	empty_agenda(Empty),
	add_axioms_to_agenda(Axioms, Empty, Agenda),
	Agenda = queue(_, TotalForms),
	retractall(total_formulas(_)),
	assert(total_formulas(TotalForms)).

exhaust(queue(Front, Back)) :-
	Front >= Back,
	!,
	retractall(max_queue_size(_)),
	assert(max_queue_size(Front)).
exhaust(Agenda0) :-
	pop_agenda(Agenda0, Index, Agenda1),
	add_item_to_chart(Index),
	add_consequences_to_agenda(Index, Agenda1, Agenda),
	exhaust(Agenda).

add_consequences_to_agenda(Index, Agenda0, Agenda) :-
	find_all_consequences(Index, Consequences),
	add_items_to_agenda(Consequences, Agenda0, Agenda).

find_all_consequences(Index, Consequences) :-
	findall(Weight-(Consequence-Justification),
		consequence(Index, Consequence, Justification, Weight),
		Consequences0),
	keysort(Consequences0, Consequences).

consequence(Index, Consequent, Justification, Weight) :-
	index_to_item(Index, Trigger),
	matching_rule(Trigger, RuleName, Others, Consequent, SideConds),
	items_in_chart(Others, Index, Indices),
	hold(SideConds),
	Justification =.. [RuleName,Index|Indices],
	get_weight(Consequent, Weight),
	notify_consequence(RuleName, Trigger, Others, SideConds, Consequent).

items_in_chart([], _MaxIndex, []).
items_in_chart([Antecedent|Antecedents], MaxIndex, [Index|Indices]) :-
	item_in_chart(Antecedent, MaxIndex, Index),
	items_in_chart(Antecedents, MaxIndex, Indices).

find_all_consequences1(Index, Consequences, Active) :-
	findall(Weight-(Consequence-Justification),
		consequence1(Index, Consequence, Active, Justification, Weight),
		Consequences0),
	keysort(Consequences0, Consequences).

consequence1(Index, Consequent, Active, Justification, Weight) :-
	index_to_item(Index, Trigger),
	matching_rule(Trigger, RuleName, Others, Consequent, SideConds),
	items_in_chart(Others, Indices),
	/* items should still be active to allow a rule to trigger */
	ord_subset(Indices, Active),
	hold(SideConds),
	Justification =.. [RuleName,Index|Indices],
	get_weight(Consequent, Weight),
	notify_consequence(RuleName, Trigger, Others, SideConds, Consequent).

items_in_chart([], []).
items_in_chart([Antecedent|Antecedents], [Index|Indices]) :-
	item_in_chart(Antecedent, Index),
	items_in_chart(Antecedents, Indices).


hold([]).
hold([Cond|Conds]) :-
	call(Cond),
	hold(Conds).

matching_rule(Trigger, RuleName, Others, Consequent, SideConds) :-
	inference(RuleName, Antecedent, Consequent, SideConds),
	select(Trigger, Antecedent, Others).

:- dynamic stored/6.
:- dynamic key_index/2.

% depracated declaration, will disappear from soon! RM

%:- index(stored(1,1,1,1,0,0)).

item_stored(Item, Index) :-
	Item = item(Formula, I, J, Data),
	calculate_key_index(Formula, Key, Index),
	stored(Index, Key, I, J, Formula, Data).

% = calculate_key_index(+Formula, +Index, -Key)
%
% true if Key is a unique hashkey for Formula. Since
% hashkeys are only defined for ground terms, this will
% return a variable (matching all keys) if Formula is not
% ground.

calculate_key_index(Formula0, Key, Index) :-
	simplify_formula(Formula0, Formula),
	ground(Formula),
	!,
        simplified_formula_to_key(Formula, Key),
        key_index(Key, Index).
calculate_key_index(_, _, _).


similar_item(Item, item(Formula, I, J, Data), IndexofSimilar) :-
	Item = item(Formula, I, J, _),
	simplify_formula(Formula, SForm),
	simplified_formula_to_key(SForm, Key),
	key_index(Key, IndexofSimilar),
	stored(IndexofSimilar, Key, I, J, Formula, Data).

subsumed_item(Item, Front, Justif) :-
	similar_item(Item, OtherItem, IndexofSimilar),
	subsumes_item(OtherItem, Item, IndexofSimilar, Front, Justif).

subsumes_item(item(F0, I0, J0, Data0), item(F, I, J, Data1), IndexofSimilar, _Front, Justif) :-
	subsumes_chk(F0, F),
	subsumes_chk(I0, I),
	subsumes_chk(J0, J),
	subsumes_data(Data0, Data1, O),
	keep_least_crossings(O, IndexofSimilar, F0, F, I0, I, J0, J, Data0, Data1, Justif).


subsumes_data(data(_,_,Prob0,A0,B0,C0),data(_,_,Prob,A,B,C), O) :-
	subsumes_chk(A0, A),
	subsumes_chk(B0, B),
	subsumes_chk(C0, C),
	compare(O, Prob0, Prob).

% TODO: test 
% If the old value is *identical* to the new one, but the probability is lower,
% then erase the old value and fail the subsumption test. Otherwise, succeed.

keep_least_crossings(>, IndexofSimilar, F0, F, I0, I, J0, J, Data, BetterData, Justif) :-
	F0 == F,
	I0 == I,
	J0 == J,
	!,
	Data = data(Pros0,Sem0,Prob0,_,_,_),
	BetterData = data(Pros1,Sem1,Prob,_,_,_),
	numbervars(Sem0, 0, _),
	reduce_sem(Sem0, RSem0),
	numbervars(Sem1, 0, _),
	reduce_sem(Sem1, RSem1),
	/* delete the previous item */
	retract(stored(IndexofSimilar, H, I, J, F, Data)),
	assertz(stored(IndexofSimilar, H, I, J, F, BetterData)),
	retract(justification(IndexofSimilar, _)),
	assert(justification(IndexofSimilar, Justif)),
   (
        verbose
   ->
	format('REPLACED (~w < ~w): ~w~nDATA:~p ~p~nBETTER DATA:~p ~p~n', [Prob, Prob0, IndexofSimilar,Pros0,RSem0,Pros1,RSem1])
   ;
        true
   ).
keep_least_crossings(=, _, _, _, _, _, _, _, _, _, _).
keep_least_crossings(<, _, _, _, _, _, _, _, _, _, _).

init_chart :-
	reset_global_counters,
	retractall(justification(_,_)),
	retractall(word(_,_,_,_,_)),
	retractall(grail_heap(_,_)),
	retractall(stored(_,_,_,_,_,_)),
	retractall(key_index(_,_)).

item_in_chart(Item, RefIndex, ItemIndex) :-
	item_stored(Item, ItemIndex),
    (
        ItemIndex =< RefIndex
    ->
        true
    ;
        !,
        fail
    ).

item_in_chart(Item, ItemIndex) :-
	item_stored(Item, ItemIndex).

item_in_chart(Item) :-
	item_stored(Item, _).

add_item_to_chart(Index) :-
	notify_chart_addition(Index).

empty_agenda(queue(0,0)).

pop_agenda(queue(Front,Back), Front, queue(NewFront, Back)) :-
	Front < Back,
	NewFront is Front + 1.

% = update_data
%
% add extraction information to Bs

update_data(data(Pros, Sem, Prob, As, Bs, Cs), _, _, _, data(Pros, Sem, Prob, As, Bs, Cs)).


add_item_to_agenda(Item0, Justification, queue(Front,Back), queue(Front, NewBack)) :-
	Item0 = item(F, I, J, Data0),
        update_data(Data0, I, J, F, Data),
	Item = item(F, I, J, Data),
	notify_agenda_addition(Item),
    (
        \+ subsumed_item(Item, Front, Justification)
    ->
        simplify_formula(F, SF),
        simplified_formula_to_key(SF, Key),
        assertz(stored(Back, Key, I, J, F, Data)),
        assert(key_index(Key, Back)),
        assertz(justification(Back, Justification)),
        NewBack is Back + 1
    ;
        NewBack = Back
    ),
        notify_agenda_size(Front, NewBack).

add_items_to_agenda([], Agenda, Agenda).
add_items_to_agenda([_-(Item-Justification)|Items], Agenda0, Agenda) :-
	!,
	add_item_to_agenda(Item, Justification, Agenda0, Agenda1),
	add_items_to_agenda(Items, Agenda1, Agenda).

add_axioms_to_agenda([], Agenda, Agenda).
add_axioms_to_agenda([Item|Items], Agenda0, Agenda) :-
	add_item_to_agenda(Item, axiom, Agenda0, Agenda1),
	add_axioms_to_agenda(Items, Agenda1, Agenda).

add_axioms_to_chart([], N, N, []).
add_axioms_to_chart([Item|Items], N0, N, [N0|Ls]) :-
	add_item_to_agenda(Item, axiom, queue(N0,N0), _),
	N1 is N0 + 1,
	add_axioms_to_chart(Items, N1, N, Ls).


index_to_item(Index, item(F, I, J, Sem)) :-
	stored(Index, _, I, J, F, Sem).

final_item(item(Start,0,Length,D), Best, BestSem) :-
	sentence_length(Length),
	has_empty_stack(D),
	findall(W-(Index-appl(SemI,Sem)),(item_in_chart(item(Start,0,Length,D), Index),get_data_weight(D,W),get_data_semantics(D,Sem),startsymbol(Start, SemI)), Solutions0),
	keysort(Solutions0, Solutions),
	Solutions = [_-(Best-BestSem)|_].

simplified_formula_to_key(SimplifiedFormula, Key) :-
	term_hash(SimplifiedFormula, Key).


% = compute_proof

new_proof_index(I, J, K) :-
	proof_index(I0),
	I is I0 + 1,
	retractall(proof_index(_)),
	assert(proof_index(I)),
	assert(proof_index_right(I, J, K)).


compute_proof(Index) :-
     (
	 output_natural_deduction_proofs(true)
     ->
         compute_proof1(Index)
     ;
         true
     ).
	      
compute_proof1(Index) :-
	check_proof_stream,
	check_prolog_proof_stream,
	check_xml_stream,
	retractall(proof_index(_)),
	assert(proof_index(-1)),
	retractall(proof_index_right(_,_,_)),
	retractall(proof_hole(_,_,_,_,_)),
	current_sentence(Sent),
	justification(Index, Just),
	Just =.. [Rule|Args],
	stored(Index, _, L, R, Formula, _),
	compute_proof(Rule, Args, L, R, _Ant, Formula, Proof),
	!,
	print_proof(Sent, Proof, pl_proof),
	xml_proof(Sent, Proof, xml),
%	portray_clause(pl_proof, (proof(Sent, Proof) :- true)),
	format(proof, '~n\\begin{multline}~n', []),
	latex_proof(Proof, proof),
	format(proof, '~n\\end{multline}~2n', []).
compute_proof1(Index) :-
    (
	current_predicate('$CHART_CURRENT'/1)
    ->
        '$CHART_CURRENT'(CUR)
    ;
        CUR = 1
    ),
	format(proof, '% FAILED to compute proof for index ~w (~w)~n', [CUR,Index]),
	format(log, 'FAILED to compute proof for index ~w (~w)~n', [CUR,Index]),
	format('FAILED to compute proof for index ~w (~w)~n', [CUR,Index]).

compute_proof(axiom, [], L, R, leaf(L,R,W,POS,Lemma), F, rule(ax, leaf(L,R,W,POS,Lemma), F, [])) :-
	word(W, POS, Lemma, L, R).
compute_proof(dr, [A,B], I, K, p(0,I,K,WL,WR), F, rule(dr, p(0,I,K,WL,WR), F, [Left,Right])) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
	justification(A, JustA),
	justification(B, JustB),
	JustA =.. [RuleA|ArgsA],
	JustB =.. [RuleB|ArgsB],
    (
        I = AL, AR = BL, AR = J, K = BR
    ->
        FA = dr(Ind,F,FB),
        compute_proof(RuleA, ArgsA, I, J, WL, FA, Left),
        compute_proof(RuleB, ArgsB, J, K, WR, FB, Right)
    ;
        I = BL, BR = AL, BR = J, K = AR
    ->
        FB = dr(Ind,F,FA),
        compute_proof(RuleB, ArgsB, I, J, WL, FB, Left),
        compute_proof(RuleA, ArgsA, J, K, WR, FA, Right)     
    ).
compute_proof(dl, [A,B], I, K, p(0,I,K,WL,WR), F, rule(dl, p(0,I,K,WL,WR), F, [Left,Right])) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
	justification(A, JustA),
	justification(B, JustB),
	JustA =.. [RuleA|ArgsA],
	JustB =.. [RuleB|ArgsB],
    (
        I = AL, AR = BL, AR = J, K = BR
    ->
        FB = dl(Ind,FA,F),
        compute_proof(RuleA, ArgsA, I, J, WL, FA, Left),
        compute_proof(RuleB, ArgsB, J, K, WR, FB, Right)
    ;
        I = BL, BR = AL, BR = J, K = AR
    ->
        FA = dl(Ind,FB,F),
        compute_proof(RuleB, ArgsB, I, J, WL, FB, Left),
        compute_proof(RuleA, ArgsA, J, K, WR, FA, Right)     
    ).
compute_proof(let, [A,B], _I, _K, W, F, Proof) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
    (
        FA = lit(let)
    ->
        F = FB,
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleA, ArgsA, AL, AR, _, FA, _),
        compute_proof(RuleB, ArgsB, BL, BR, W, F, Proof)
    ;
        FB = lit(let)
    ->
        F = FA,
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleB, ArgsB, BL, BR, _, FB, _),
	compute_proof(RuleA, ArgsA, AL, AR, W, F, Proof)
    ).
compute_proof(wr, [A,B], I, K, W, F, Proof) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
    (
        /* A is right of and ajactent to B */
        BL = I, AR = K, BR = AL, BR = J
    ->
        F = FB,
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleA, ArgsA, AL, AR, WA, FA, ProofA),
        compute_proof(RuleB, ArgsB, BL, BR, W, F, Proof),
        assert(proof_hole(AL, AR, WA, FA, ProofA))
    ;
        AL = I, BR = K, AR = BL, AR = J
    ->
        F = FA,
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
	compute_proof(RuleA, ArgsA, AL, AR, W, F, Proof),
        compute_proof(RuleB, ArgsB, BL, BR, WB, FB, ProofB),
        assert(proof_hole(BL, BR, WB, FB, ProofB))
    ).

compute_proof(wpop_vp, [A], I, K, W, dl(0,lit(np(N1,N2,N3)),lit(s(S))), rule(dli(VI), W, dl(0,lit(np(N1,N2,N3)),lit(s(S))), [rule(dl, p(0,I,K,hyp(I,I,'$VAR'(VI)),W), lit(s(S)), [rule(dl, p(0,I,K,hyp(I,I,'$VAR'(VI)),WA), lit(s(S)), [rule(hyp(VI), hyp(I,I,'$VAR'(VI)), lit(np(N1,N2,N3)), []),ProofA]), ProofH])])) :-
	new_proof_index(VI, K, I),
	stored(A, _, I, K, dl(0,lit(np(N1,N2,N3)),lit(s(S))), _),
	justification(A, JustA),
	JustA =.. [RuleA|ArgsA],
	compute_proof(RuleA, ArgsA, I, K, WA, dl(0,lit(np(N1,N2,N3)),lit(s(S))), ProofA),
	proof_hole(I0, K0, WB, dl(1,lit(s(S)),lit(s(S))), ProofH),
	I0 >= I,
	K0 =< K,
	insert_pros(WA, I0, K0, WB, W).

compute_proof(wpop_vpi, [A,B], I, K, p(0,I,K,WB,WA), dl(0,lit(np(N1,N2,N3)),lit(s(S))), rule(dli(VI), p(0,I,K,WB,WA), dl(0,lit(np(N1,N2,N3)),lit(s(S))), [rule(dl, p(0,I,K,hyp(I,I,'$VAR'(VI)),p(0,I,K,WB,WA)), lit(s(S)), [rule(dl, p(0,I,K,hyp(I,I,'$VAR'(VI)),WA), lit(s(S)), [rule(hyp(VI), hyp(I,I,'$VAR'(VI)), lit(np(N1,N2,N3)), []),ProofA]), ProofB])])) :-
	new_proof_index(VI, K, I),
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
    (
        /* A is right of and ajactent to B, FA = np\s */
        BL = I, AR = K, BR = AL, BR = J
    ->
        FA = dl(0,lit(np(N1,N2,N3)),lit(s(S))),
        FB = dl(1,lit(s(S)),lit(s(S))),
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleA, ArgsA, AL, AR, WA, FA, ProofA),
        compute_proof(RuleB, ArgsB, BL, BR, WB, FB, ProofB)
     ;
        AL = I, BR = K, AR = BL, AR = J
    ->
        FB = dl(0,lit(np(N1,N2,N3)),lit(s(S))),
        FA = dl(1,lit(s(S)),lit(s(S))),
        justification(A, JustA),
        justification(B, JustB),
        JustA =.. [RuleA|ArgsA],
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleA, ArgsA, AL, AR, WB, FA, ProofB),
        compute_proof(RuleB, ArgsB, BL, BR, WA, FB, ProofA)
     ).

compute_proof(wpop, [A], I, K, W, FA, rule(dl, W, FB, [ProofA, ProofH])) :-
	stored(A, _, I, K, FA, _),
	justification(A, JustA),
	JustA =.. [RuleA|ArgsA],
	compute_proof(RuleA, ArgsA, I, K, WA, FA, ProofA),
	proof_hole(I0, K0, WB, dl(1,FA,FB), ProofH),
	I0 >= I,
	K0 =< K,
	insert_pros(WA, I0, K0, WB, W).


compute_proof(e_start, [A,B], I, K, p(0, I, K, W, hyp(K,K,'$VAR'(V))), F, rule(dr, p(0,I,K,W,hyp(K,K,'$VAR'(V))), F, [Proof,rule(hyp(V), hyp(K,K,'$VAR'(V)), Arg, [])])) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
    (
        AL = I, AR = K
    ->
        FA = dr(0,F,Arg),
        BR = Ind,
	new_proof_index(V, Ind, K),
        justification(A, JustA),
        JustA =.. [RuleA|ArgsA],
        compute_proof(RuleA, ArgsA, I, K, W, FA, Proof)
    ;
        BL = I, BR = K
    ->
        FB = dr(0,F,Arg),
        AR = Ind,
	new_proof_index(V, Ind, K),
        justification(B, JustB),
        JustB =.. [RuleB|ArgsB],
        compute_proof(RuleB, ArgsB, I, K, W, FB, Proof)
    ).

compute_proof(e_end, [A,B], I, K, p(0,I,K,WL,WR), F, rule(dr,p(0,I,K,WL,WR), F, [Left,rule(dri(PIJ), WR, FR, [Right])])) :-
	stored(A, _, AL, AR, FA, _),
	stored(B, _, BL, BR, FB, _),
	justification(A, JustA),
	justification(B, JustB),
	JustA =.. [RuleA|ArgsA],
	JustB =.. [RuleB|ArgsB],
    (
        AL = I, AR = BL, AR = J, BR = K
    ->
        FR = dr(0,FB,dia(Ind,box(Ind,G))),
        FA = dr(0,F,FR),
        compute_proof(RuleA, ArgsA, I, J, WL, FA, Left),
        compute_proof(RuleB, ArgsB, J, K, WR0, FB, Right),
        proof_index_right(PIJ, J, PI),
        valid_extraction(Ind, PI, K),
        retract_hypothesis(PIJ, PI, WR0, WR)
    ;
        I = BL, BR = AL, BR = J, K = AR
     ->
        FR = dr(0,FA,dia(Ind,box(Ind,G))),
        FB = dr(0,F,FR),
        compute_proof(RuleB, ArgsB, I, J, WL, FB, Left),
        compute_proof(RuleA, ArgsA, J, K, WR0, FA, Right),      
        proof_index_right(PIJ, J, PI),
        valid_extraction(Ind, PI, K),
        retract_hypothesis(PIJ, PI, WR0, WR)
    ).


valid_extraction(0, R, R).
valid_extraction(1, _, _).

insert_pros(leaf(L,R,W,P,Lem), LWB, RWB, WB, p(0,L,RWB,leaf(L,R,W,P,Lem),WB)) :-
	LWB >= R.
insert_pros(p(0,L,R,A,B), C_L, C_R, C, Inserted) :-
        left_most(B, B_L),
     (
        C_R >= R
     ->
        Inserted = p(0,L,C_R,p(0,L,R,A,B),C)
     ;
        C_L =< B_L
     ->
        Inserted = p(0,L,R,NA,B),
        insert_pros(A, C_L, C_R, C, NA)
     ;
        /* B_L < C_L */
        Inserted = p(0,L,R,A,NB),
        insert_pros(B, C_L, C_R, C, NB)
     ).
      
insert_pros(LR0-W, LR, WB, p(0,LR0-W,WB)) :-
	LR0 =< LR.
insert_pros(p(0,A0,B0), LWB, WB, Inserted) :-
	right_most(B0, RB),
     (
        LWB >= RB
    ->
        Inserted=p(0,p(0,A0,B0),WB)
     ;
	right_most(A0, R),
    (
        LWB >= R
    ->
        Inserted = p(0,p(0,A0,WB),B0)
    ;
        LWB < R
    ->
        Inserted = p(0,A,B0),
        insert_pros(A0, LWB, WB, A)
    ;
        left_most(B0, L),
     (
        LWB < L
     ->
        Inserted = p(0,p(0,A0,WB),B0)
     ;
        Inserted = p(0,A0,B),
        insert_pros(B0, LWB, WB, B)
     ))).

right_most(hyp(_,R,_), R).
right_most(leaf(_,R,_,_,_), R).
right_most(p(_,_,R,_,_), R).

left_most(hyp(L,_,_), L).
left_most(leaf(L,_,_,_,_), L).
left_most(p(_,L,_,_,_), L).


retract_hypothesis(I, R, p(0, _, R, V, hyp(_,R,'$VAR'(I))), V) :-
	!.
retract_hypothesis(I, RI, p(0, L, R, V0, W0), Result) :-
	right_most(V0, VR),
    (
        RI =< VR
    ->
        Result = p(0, L, R, V, W0),
        retract_hypothesis(I, RI, V0, V)
    ;
        Result = p(0, L, R, V0, W),
        retract_hypothesis(I, RI, W0, W)
    ).
     
% = application rules

inference(dr, [item(dr(M,X,Y), I, J, Data1), item(Y, J, K, Data2)],
	       item(X, I, K, Data),
               [application_r(M, I, K, Data1, Data2, Data),check_wrap(Y, Data2), valid_extraction(Data, I)]).

inference(dl, [item(Y, I, J, Data1), item(dl(M,Y,X), J, K, Data2)],
	       item(X, I, K, Data),
               [check_islands(Y,Data2),application_l(M, I, K, Data2, Data1, Data),valid_extraction(Data, I)]).


% = rules for skipping interpunction symbols

inference(let, [item(X, I, J, Data1),item(lit(let), J, K, Data2)],
	         item(X, I, K, Data),
	         [J is I+1, combine_let(r,I,K,Data1,Data2,Data)]).  % prevent "attachment ambiguity"
inference(let, [item(lit(let), 0, I, Data2),item(X, I, J, Data1)],
	         item(X, 0, J, Data),
	         [X\==lit(let),combine_let(l,0,J,Data1,Data2,Data)]).

% = wrapping rules

% push the item on the stack

inference(wr, [item(X, I, J, Data1), item(dl(1,V,W), J, K, Data2)],
	       item(X, I, K, Data),
              [J is I+1, wrap(dl(1,V,W), I, J, K, Data1, Data2, Data)]).

inference(wpop, [item(X, I0, J0, Data0)],
	         item(Y, I, J, Data),
	        [pop(dl(1,X,Y), I0, J0, I, J, Data0, Data)]).

% special rule to allow an s-modifier to modify a vp

inference(wpop_vp, [item(dl(0,lit(np(A,B,C)),lit(s(S))), I0, J0, Data0)],
	            item(dl(0,lit(np(A,B,C)),lit(s(S))), I, J, Data),
	           [pop_vp(I0, J0, I, J, Data0, Data)]).

inference(wpop_vpi, [item(dl(0,lit(np(A,B,C)),lit(s(S))), J, K, Data0),item(dl(1,lit(s(S)),lit(s(S))),I,J,Data1)],
	             item(dl(0,lit(np(A,B,C)),lit(s(S))), I, K, Data),
	            [adv_vp(Data1, Data0, Data)]).

% = special case for reported speech of the form "SENT, a dit NP"

inference(a_dit, [item(dr(0,dr(0,lit(s(X)),lit(np(A,B,C))),dl(0,lit(np(A,B,C)),lit(s(INFL)))), I, J, Data1),
		  item(dl(1,lit(s(X)),dl(0,lit(np(A,B,C)),lit(s(INFL)))), J, K, Data2)],
	          item(dr(0,dl(1,lit(s(X)),lit(s(X))),lit(np(A,B,C))), I, K, Data),
	         [a_dit(I, K, Data1, Data2, Data)]).
inference(a_np_dit, [item(dr(0,dr(0,lit(s(X)),dl(0,lit(np(A,B,C)),lit(s(INFL)))),lit(np(D,E,F))), I, J, Data1),
		     item(lit(np(D,E,F)), J, K, Data2),
		     item(dl(1,lit(s(X)),dl(0,lit(np(A,B,C)),lit(s(INFL)))), K, L, Data3)],
	             item(dl(1,lit(s(X)),lit(s(X))), I, L, Data),
	         [a_np_dit(I, L, Data1, Data2, Data3, Data)]).

% = right-extraction rules

inference(e_start, [item(dr(0,_,dr(0,_,dia(Ind,box(Ind,Y)))),_,K,_),item(dr(0,X,Y), I, J, Data0)],
		    item(X, I, J, Data),
		   [K=<I,no_island_violation(Ind,X,Y),start_extraction(Y, J, K, Data0, Data)]).
inference(e_end, [item(dr(0,X,dr(0,Y,dia(Ind,box(Ind,Z)))), I, J, Data0), item(Y, J, K, Data1)],
	          item(X, I, K, Data),
	         [check_extraction(Ind,K0,K),end_extraction(Z, K0, J, Data0, Data1, Data),valid_extraction(Data, I)]).

inference(e_start_l, [item(dl(0,dr(0,_,dia(0,box(0,Y))),_),K,_,_),item(dr(0,X,Y), I, J, Data0)],
		      item(X, I, J, Data),
		     [J=<K,no_island_violation(0,X,Y),start_extraction_l(Y, J, K, Data0, Data)]).
inference(e_end_l, [item(dl(0,dr(0,Y,dia(0,box(0,Z))),X), J, K, Data0), item(Y, I, J, Data1)],
	            item(X, I, K, Data),
	           [end_extraction_l(Z, J, J, Data0, Data1, Data),valid_extraction(Data, I)]).

% = product rules

inference(prod_e, [item(p(0,dr(0,X,Y),Y), I, J, data(Pros,Sem0,Prob,SetA,SetB,SetC))],
	           item(X, I, J, data(Pros,appl(pi1(Sem0),pi2(Sem0)),Prob,SetA,SetB,SetC)),
	          []).
inference(prod_i, [item(X, I, J, data(Pros0,Sem0,Prob0,SetA0,SetB0,SetC0)), item(Y, J, K, data(Pros1,Sem1,Prob1,SetA1,SetB1,SetC1)),item(F,I0,J0,_)],
	          item(p(0,X,Y), I, K, data(p(0,Pros0,Pros1),pair(Sem0,Sem1), Prob, SetA, SetB, SetC)),
	          [prod_formula(F,p(0,X,Y),I0,J0,I,K),combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC),combine_probability(Prob0,Prob1,I,K,prod_i,Prob)]).
inference(prod_w, [item(p(0,X,dl(1,Y,Z)), I, J, data(Pros,Sem,Prob,SetA,SetB,SetC))],
	           item(X, I, J, data(Pros,pi1(Sem),Prob,[t(I,J,dl(1,Y,Z),pi2(Sem))|SetA],SetB,SetC)),
		  []).
inference(prod_c, [item(dr(0,X,Y), I, J, data(Pros1,Sem1,Prob0,SetA0,SetB0,SetC0)), item(p(0,Y,dia(0,box(0,Z))), J, K, data(p(0,Pros2,Pros3),Sem2,Prob1,SetA1,SetB1,SetC1))],
	           item(p(0,X,Z), I, K, data(p(0,p(0,Pros1,Pros2),Pros3),pair(appl(Sem1,pi1(Sem2))),Prob,SetA,SetB,SetC)),
	          [combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC),combine_probability(Prob0,Prob1,I,K,prod_c,Prob)]).

% = gapping rules

inference(gap_init, [item(dr(0,dl(0,dr(0,lit(s(S)),dia(1,box(1,Z))),dr(0,lit(s(S)),box(1,dia(1,Z)))),dr(0,lit(s(S)),dia(1,box(1,Z)))), I, J, Data)],
	             item(gap(s(S),Z), I, J, Data),
	            []).
inference(gap_insert, gap(s(S)

prod_formula(dr(0,_,p(0,X,Y)), p(0,X,Y), _, J, J, _).
prod_formula(dl(0,p(0,X,Y),_), p(0,X,Y), I, _, _, I).

no_island_violation(1, Formula, Gap) :-
	island_violation(Formula, Gap),
	!,
	fail.
no_island_violation(_, _, _).

island_violation(lit(pp(_)), lit(np(_,_,_))).
island_violation(dl(1,lit(s(_)),lit(s(_))), lit(np(_,_,_))).
island_violation(dr(0,lit(s(_)),lit(s(_))), lit(np(_,_,_))).

check_extraction(0, K, K).
check_extraction(1, _, _).

% np island constraint

check_islands(lit(np), Data) :-
	!,
	Data = data(_, _, _, _, [], []).
check_islands(lit(pp(_)), Data) :-
	!,
	Data = data(_, _, _, _, [], []).
check_islands(_, _).

% = wrapped adjective modifiers must be bound in the embedding np

check_np_wrap([]).
check_np_wrap([X|Xs]) :-
	X \= dl(1,dl(0,n,n),dl(0,n,n)),
	check_np_wrap(Xs).

check_wrap(dl(0,lit(np(_,_,_)),lit(s(_))), Data) :-
	!,
	Data = data(_, _, _, [], _, _).
check_wrap(lit(s(_)), Data) :-
	!,
	Data = data(_, _, _, [], _, _).
check_wrap(_, _).

has_empty_stack(data(_, _, _, [], [], [])).


combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC) :-
	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB1, SetB),
	ord_key_union_i(SetC0, SetC1, SetC).

%dit_mod(data(Pros1, Sem1, Prob1, SetA0, SetB0, SetC0),
%	data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
%	data(p(0,Pros1, Pros2), 
combine_let(Dir, J, K, data(Pros0, Sem, Prob1, SetA0, SetB0, SetC0),
	         data(Pros1   , _  , Prob2, SetA1, SetB1, SetC1),
	         data(Pros, Sem, Prob, SetA, SetB, SetC)) :-
	combine_probability(Prob1, Prob2, J, K, let, Prob),
	combine_pros(Dir, Pros0, Pros1, Pros),
	combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC).

combine_pros(l, Pros0, Pros1, p(0,Pros1,Pros0)).
combine_pros(r, Pros0, Pros1, p(0,Pros0,Pros1)).

application_l(M, J, K, data(Pros1, Sem1, Prob1, SetA0, SetB0, SetC0),
	         data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
	         data(p(M,Pros2,Pros1), appl(Sem1,Sem2), Prob, SetA, SetB, SetC)) :-
	combine_probability(Prob1, Prob2, J, K, appl_l(Pros1,Pros2), Prob),
	combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC).
application_r(M, J, K, data(Pros1, Sem1, Prob1, SetA0, SetB0, SetC0),
	         data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
	         data(p(M,Pros1,Pros2), appl(Sem1,Sem2), Prob, SetA, SetB, SetC)) :-
	combine_probability(Prob1, Prob2, J, K, appl_r(Pros1,Pros2), Prob),
	combine_sets(SetA0, SetB0, SetC0, SetA1, SetB1, SetC1, SetA, SetB, SetC).

a_dit(J, K, data(Pros1, Sem1, Prob1, SetA0, SetB0, SetC0),
      data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
      data(p(0,Pros1,Pros2), lambda(NP, lambda(S, appl(appl(Sem1,appl(Sem2,S)),NP))), Prob, SetA, SetB, SetC)) :-
	crosses(J, K, Cross),
	Prob is Prob1 + Prob2 + Cross,
      	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB1, SetB),
        ord_key_union_i(SetC0, SetC1, SetC).

a_np_dit(J, K, data(Pros1, Sem1, Prob1, SetA0, SetB0, SetC0),
         data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
	 data(Pros3, Sem3, Prob3, SetA2, SetB2, SetC2),
         data(p(0,p(0,Pros1,Pros2),Pros3), lambda(S, appl(appl(Sem1,Sem2),appl(Sem3,S))), Prob, SetA, SetB, SetC)) :-
	crosses(J, K, Cross),
        Prob is Prob1 + Prob2 + Prob3 + Cross,
      	append(SetA0, SetA1, SetA01),
	append(SetA01, SetA2, SetA),
	ord_key_union_i(SetB0, SetB1, SetB01),
	ord_key_union_i(SetB01, SetB2, SetB),
        ord_key_union_i(SetC0, SetC1, SetC01),
	ord_key_union_i(SetC01, SetC2, SetC).


% = wrapping
%
% "wrap" infixes are pused onto SetA

wrap(dl(1,V,W), I, J, K, data(Pros1, Sem, Prob1, SetA0, SetB0, SetC0),
                      data(Pros2, Sem2, Prob2, SetA1, SetB1, SetC1),
                      data(p(1,Pros1,Pros2), Sem, Prob, [t(J,K,dl(1,V,W),Sem2)|SetA], SetB, SetC)) :-
	crosses(I, K, Cross),
	Prob is Prob1 + Prob2 + Cross,
	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB1, SetB),
	ord_key_union_i(SetC0, SetC1, SetC).

pop(X, I1, J1, I, J, data(Pros, Sem, Prob, SetA0, SetB, SetC), data(Pros, appl(Sem0,Sem), Prob, SetA, SetB, SetC)) :-
	select(t(I0,J0,X,Sem0), SetA0, SetA),
	/* verify the wrapped constituent is a substing of the current string */
	verify_wrap(I1, I0, J0, J1, I, J),
	!.

pop_vp(I1, J1, I, J, data(Pros, Sem, Prob, SetA0, SetB, SetC), data(Pros, lambda(X,appl(Sem0,appl(Sem,X))), Prob, SetA, SetB, SetC)) :-
	select(t(I0,J0,dl(1,lit(s(S)),lit(s(S))),Sem0), SetA0, SetA),
	verify_wrap(I1, I0, J0, J1, I, J),
	!.

adv_vp(data(Pros0, Sem0, Prob0, SetA0, SetB0, SetC0),
       data(Pros1, Sem1, Prob1, SetA1, SetB1, SetC1),
       data(p(0,Pros0, Pros1), lambda(X,appl(Sem0,appl(Sem1,X))), Prob, SetA, SetB, SetC)) :-
	Prob is Prob0 + Prob1,
	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB1, SetB),
	ord_key_union_i(SetC0, SetC1, SetC).
	

% I = I1 --- I0 --- J0 --- J1 = J

verify_wrap(I, I0, J0, J, I, J) :-
	I0 >= I,
	J0 =< J,
	!.
% I = I0 --- J0 = I1 -- J1 = J
verify_wrap(I1, I0, J0, J1, I, J) :-
	format('I0:~w I1: ~w J0: ~w J1: ~w', [I0,I1,J0,J1]),
	I0 = I,
	J0 = I1,
	J1 = J.
	
% = extraction

% = start_extraction(+ExtractedFormula, RightEdgeOfFormula, RightEdgeOfIntroduction, Data1 Data2)
%
% ExtractedFormula: formula extracted
% RightEdgeOfFormula: string position where the formula has been inserted
% RightEdgeOfIntroduction: string position where the higher-order formula authorizing the introduction ends
%
% SetC has entries of the form IntroRightEdge-r(Formula,FormRightEdge,SemVar)
% with meaning Formula-SemVar has been used at string position J-J (FormRightEdge)

start_extraction(Y, J, K, data(Pros, Sem, Prob, SetA, SetB, SetC0), data(Pros, appl(Sem,X), Prob, SetA, SetB, SetC)) :-
	ord_key_insert_i(SetC0, K, t(Y,J,X), SetC).

% SetC = 

start_extraction_l(Y, J, K, data(Pros, Sem, Prob, SetA, SetB0, SetC), data(Pros, appl(Sem,X), Prob, SetA, SetB, SetC)) :-
	ord_key_insert_i(SetB0, K, t(Y,J,X), SetB).

end_extraction_l(Y, J, K, data(Pros0, Sem0, Prob0, SetA0, SetB0, SetC0),
                       data(Pros1, Sem1, Prob1, SetA1, SetB1, SetC1),
	               data(p(0,Pros1,Pros0), appl(Sem1,lambda(X,Sem0)), Prob, SetA, SetB, SetC)) :-
	select(K-t(Y,J,X), SetB1, SetB2),
	!,
	crosses(J, K, Cross),
	Prob is Prob0 + Prob1 + Cross,
	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB2, SetB),
	ord_key_union_i(SetC0, SetC1, SetC).


end_extraction(Y, J, K, data(Pros0, Sem0, Prob0, SetA0, SetB0, SetC0),
                  data(Pros1, Sem1, Prob1, SetA1, SetB1, SetC1),
	          data(p(0,Pros0,Pros1), appl(Sem0,lambda(X,Sem1)), Prob, SetA, SetB, SetC)) :-
	select(K-t(Y,J,X), SetC1, SetC2),
	!,
	crosses(J, K, Cross),
	Prob is Prob0 + Prob1 + Cross,
	append(SetA0, SetA1, SetA),
	ord_key_union_i(SetB0, SetB1, SetB),
	ord_key_union_i(SetC0, SetC2, SetC).

valid_extraction(data(_, _, _, _, _, SetC), K) :-
	valid_item(SetC, K).

valid_item([], _).
valid_item([K-_|_], K0) :-
	K0 >= K.

notify_agenda_size(Head, Tail) :-
    (
       verbose
    ->
       format('Agenda size: ~w - ~w', [Head, Tail])
    ;
       true
    ).

notify_consequence(RuleName, Trigger, Others, SideConds, Consequent) :-
    (
        verbose
    ->
        format(' ~p:~n     trigger: ~p~n', [RuleName, Trigger]),
        format('     others: ~p~n', [Others]),
        format('     side conds: ~p~n', [SideConds]),
        format('     cons: ~p~n', [Consequent])
    ;
        true
    ).

notify_agenda_addition(Item) :-
    (
         verbose
    ->
         Item = item(Formula,I,J,Data),
         simplify_formula(Formula, SForm),
         format('~NAdding to agenda: <-> ~p-~p ~p ~@~n', [I,J,SForm,print_stacks(Data)])
    ;
         print('.')
    ).

notify_chart_addition(Index) :-
    (
        verbose
    ->
	index_to_item(Index, item(Formula,I,J,Data)),
        simplify_formula(Formula, SForm),
        simplified_formula_to_key(SForm, Key),
        format('~NAdding to chart: <~p-~p-~p> ~p ~@~n', [Key,I,J,SForm,print_stacks(Data)])
    ;
        print(':')
    ).


print_stacks(data(_,_,_,[],[],[])) :-
	!.
print_stacks(data(_,_,_,As,Bs,Cs)) :-
	format('{~p ~p ~p}', [As,Bs,Cs]).

create_data(Pros, _Form, _Prob, Sem, _I, _J, data(Pros, Sem, 0, [], [], [])).


simplify_formula(X, X) :-
	var(X),
	!.
simplify_formula(lit(s(_)), s) :- !.
simplify_formula(lit(pp(_)), pp) :- !.
simplify_formula(lit(np(_,_,_)), np) :- !.
simplify_formula(lit(A), A).
simplify_formula(dl(I,A0,B0), dl(I,A,B)) :-
	simplify_formula(A0, A),
	simplify_formula(B0, B).
simplify_formula(dr(I,A0,B0), dr(I,A,B)) :-
	simplify_formula(A0, A),
	simplify_formula(B0, B).
simplify_formula(p(I,A0,B0), p(I,A,B)) :-
	simplify_formula(A0, A),
	simplify_formula(B0, B).
simplify_formula(dia(_,A0), dia(1,A)) :-
	simplify_formula(A0, A).
simplify_formula(box(_,A0), box(1,A)) :-
	simplify_formula(A0, A).

% = ord_key_insert_i(+OrdSet, +Key, +Data, -OrdSet)
%
% as ord_insert/3, but assumes the elements of OrdSet are Key-Value
% pairs; uses *inverse* ordering                                     RM

ord_key_insert_i([], Key, Data, [Key-Data]).
ord_key_insert_i([Key-Data|Tail], Key0, Data0, Rest) :-
	compare(Order, Key0, Key),
	ord_key_insert_i(Order, Tail, Key0, Data0, Key, Data, Rest).

ord_key_insert_i(>, Tail, Key0, Data0, Key, Data, [Key0-Data0,Key-Data|Tail]).
ord_key_insert_i(=, Rest, Key, Data0, Key, _Data, [Key-Data0|Rest]).
ord_key_insert_i(<, Tail, Key0, Data0, Key, Data, [Key-Data|Rest]) :-
	ord_key_insert_i(Tail, Key0, Data0, Rest).


% = ord_key_union(+Map1, +Map2, ?Map3)
%
% as ord_union/3, but for ordered sets of Key-Value pairs, where Value
% is itself an ordered set. If Map1 and Map2 contain the same Key,
% Map3 will contain the ord_union of the two values.                RM

ord_key_union_i([], Set2, Set2).
ord_key_union_i([H1-V1|T1], Set2, Union) :-
	ord_key_union_2_i(Set2, H1, V1, T1, Union).

ord_key_union_2_i([], H1, V1, T1, [H1-V1|T1]).
ord_key_union_2_i([H2-V2|T2], H1, V1, T1, Union) :-
	compare(Order, H1, H2),
	ord_key_union_3_i(Order, H1, V1, T1, H2, V2, T2, Union).

ord_key_union_3_i(>, H1, V1, T1, H2, V2, T2, [H1-V1|Union]) :-
	ord_key_union_2_i(T1, H2, V2, T2, Union).
% NOTE: commenting out the equality restricts lexical entries to have only
% a single extraction each, since the gapping analysis will require special
% treatment in any case, this simple solution seems justified
%ord_key_union_3_i(=, H1, V1, T1, H2, V2, T2, [H1-V1,H2-V2|Union]) :-
%	V1 \== V2,
%	ord_key_union_i(T1, T2, Union).
ord_key_union_3_i(<, H1, V1, T1, H2, V2, T2, [H2-V2|Union]) :-
	ord_key_union_2_i(T2, H1, V1, T1, Union).


% = streams

check_log_stream :-
    (
	is_stream(log)
    ->
        true
    ;
        new_output_file(grail_log, log)
    ).

check_proof_stream :-
    (
	is_stream(proof)
    ->
        true
    ;
        new_output_file('proof.tex', proof)
    ).

check_prolog_proof_stream :-
   (
       is_stream(pl_proof)
   ->
       true
   ;
       new_output_file('proofs.pl', pl_proof)
   ).

check_xml_stream :-
   (
       is_stream(xml)
   ->
       true
   ;
       new_output_file('proofs.xml', xml)
   ).

% = new_output_file(+File, +Alias)
%
% opens File to be accessed by Alias
% An old file of the same name, if it exists, is deleted.
% If opening the file raises an exception (because of permissions)
% a null stream is opened instead.

new_output_file(File, Alias) :-
        delete_file_if_exists(File),
	catch(open(File, update, _, [alias(Alias),buffer(line)]),
	      _, 
	      open_null_stream(Alias)).

delete_file_if_exists(File) :-
    (
        exists_file(File),
	access_file(File, write)
    ->
	delete_file(File)
    ;
	true
    ).

reset_global_counters :-
	retractall('$SOLUTION'(_)),
	assert('$SOLUTION'(0)),
	statistics(cputime, CPU),
	assert('$START_CPU'(CPU)),
	statistics(inferences, INF),
	assert('$START_INF'(INF)).

increase_global_counter(Functor) :-
	functor(Term, Functor, 1),
	call(Functor, Num0),
	Num is Num0 + 1,
	retractall(Term),
	arg(1, Term, Num),
	assert(Term).

increase_global_counter(Functor, Num) :-
	functor(Term, Functor, 1),
	call(Functor, Num0),
	Num is Num0 + 1,
	retractall(Term),
	arg(1, Term, Num),
	assert(Term).

set_global_counter(Functor, Num) :-
	functor(Term, Functor, 1),
	retractall(Term),
	arg(1, Term, Num),
	assert(Term).


pdflatex_semantics :-
    (
	option_true(latex)
    ->
	shell_warn('pdflatex semantics.tex >> texlog &')
    ;
	true
    ).

open_semantics_files :-
	new_output_file('semantics.tex', sem),
	new_output_file('previous_semantics.pl', previous_sem),
	open('semantics.pl', append, _, [alias(sem_pl),buffer(line)]).

atomic_formula(D) :-
	lex(_, D0, _),
	macro_expand(D0, D1),
	atomic_formula1(D1, D).

atomic_formula1(lit(A), D) :-
    (
        compound(A)
    ->
        functor(A, D, _)
    ;
        D = A
    ).
atomic_formula1(dl(_,A,B), D) :-
    (
	atomic_formula1(A, D)
    ;
	atomic_formula1(B, D)
    ).
atomic_formula1(dr(_,A,B), D) :-
    (
	atomic_formula1(A, D)
    ;
	atomic_formula1(B, D)
    ).
atomic_formula1(p(_,A,B), D) :-
    (
	atomic_formula1(A, D)
    ;
	atomic_formula1(B, D)
    ).
atomic_formula1(dia(_,A), D) :-
	atomic_formula1(A, D).
atomic_formula1(box(_,A), D) :-
	atomic_formula1(A, D).

shell_warn(Cmd) :-
	shell(Cmd, Exit),
    (
        Exit = 0
    ->
        true
    ;
        format(user_err, '{Warning: Shell command failed "~w"}~n', [Cmd])
    ).

user:portray(lit(np(A,_,_))) :-
	!,
    (
        A == nom
    ->
        write(np_nom)
    ;
       A == acc
    ->
       write(np_acc)
    ;
       write(np)
    ).
user:portray(lit(s(A))) :-
	var(A),
	!,
	write(s).
user:portray(lit(s(A))) :-
	!,
	format('s_~w', [A]).

user:portray(lit(A)) :-
	!,
	write(A).
user:portray(box(0,A)) :-
	!,
	format('[]~p', [A]).
user:portray(dia(0,A)) :-
	!,
	format('<>~p', [A]).
user:portray(box(I,A)) :-
	!,
	format('[]~w ~p', [I,A]).
user:portray(dia(I,A)) :-
	!,
	format('<>~w ~p', [I,A]).

user:portray(dr(0,A,B)) :-
	!,
	format('(~p/~p)', [A,B]).
user:portray(dl(0,A,B)) :-
	!,
	format('(~p\\~p)', [A,B]).
user:portray(p(0,A,B)) :-
	!,
	format('(~p o ~p)', [A,B]).
user:portray(p(1,A,B)) :-
	!,
	format('(~p * ~p)', [A,B]).
user:portray(dr(I,A,B)) :-
	!,
	!,
	format('(~p /~w ~p)', [A,I,B]).
user:portray(dl(I,A,B)) :-
	!,
	format('(~p \\~w ~p)', [A,I,B]).
user:portray(p(I,A,B)) :-
	!,
	format('(~p o~w ~p)', [A,I,B]).
user:portray(t(I,J,F,_V)) :-
	integer(I),
	integer(J),
	!,
	format('~w-~w ~p', [I,J,F]).

xml_proof(Index, Proof, Stream) :-
	format(Stream, '<?xml version="1.0" encoding="UTF-8"?>~n', []),
	numbervars(Proof, 0, _),
	Proof = rule(_, Pros, _, _),
	format(Stream, '<!-- ~w. ', [Index]),
	print_pros_xml(Pros, Stream),
	format(Stream, '>~n', []),
	xml_proof1(Proof, 0, Stream).

xml_proof1(rule(A,B0,C,Ds), T0, Stream) :-
	reduce_pros(B0, B),
	nl(Stream),
	tab(Stream, T0),
	format(Stream, '<rule name="~w" pros="~q" formula="~w">', [A,B,C]),
	T is T0 + 3,
	xml_proof_list(Ds, T, Stream),
	nl(Stream),
	tab(Stream, T0),
	format(Stream, '</rule>', []).

xml_proof_list([], _, _).
xml_proof_list([P|Ps], T, Stream) :-
	xml_proof1(P, T, Stream),
%	nl(Stream),
%	tab(Stream, T),
	xml_proof_list(Ps, T, Stream).

print_pros_xml(leaf(_,_,Pros,_,_), Stream) :-
	print_pros_xml1(Pros, Stream).
print_pros_xml(p(_,_,_,L,R), Stream) :-
	print_pros_xml(L, Stream),
	print_pros_xml(R, Stream).

print_pros_xml1(Pros0, Stream) :-
	name(Pros0, Codes0),
	xml_codes(Codes0, Codes),
	name(Pros, Codes),
	write(Stream, Pros).

xml_codes([], []).
xml_codes([C|Cs], Ds0) :-
     (
         C = 38
     ->
         /* &amp; */
         Ds0 = [38,97,109,112,59|Ds]
     ;
         C = 39
     ->
         /* &apos; */
         Ds0 = [38,97,112,111,115,59|Ds]
     ;
         C = 34
     ->
         /* &quot; */
         Ds0 = [38,113,117,111,116,59|Ds]
     ;
         /* default */
         Ds0 = [C|Ds]
     ),
         xml_codes(Cs, Ds).

print_proof(Index, Proof, Stream) :-
	numbervars(Proof, 0, _),
	print_title(Proof, Index, Stream),
	format(Stream, 'proof(~w, ', [Index]),
	print_proof1(Proof, 0, Stream),
	format(Stream, ').~2n', []).

print_proof1(rule(RName,Pros0,Sem,Ds), T0, Stream) :-
%	reduce_pros(Pros0, Pros),
	Pros = Pros0,
    (
	Ds = []
    ->
        write_term(Stream, rule(RName, Pros, Sem, Ds), [numbervars(true),quoted(true)])
    ;
        Ds = [D|Ds0], 
        T is T0 + 3,
        format(Stream, 'rule(~W, ~W ,~W , [~n', [RName,[numbervars(true),quoted(true)],Pros,[numbervars(true),quoted(true)],Sem,[numbervars(true),quoted(true)]]),
        tab(Stream, T),
        print_proof_list(Ds0, D, T, Stream),
        format(Stream, '])', [])
    ).

print_proof_list([], D, T, Stream) :-
	print_proof1(D, T, Stream),
	nl(Stream),
	tab(Stream, T).
print_proof_list([D|Ds], D0, T, Stream) :-
	print_proof1(D0, T, Stream),
	write(Stream, ','),
	nl(Stream),
	tab(Stream, T),
	print_proof_list(Ds, D, T, Stream).

print_title(rule(_, Pros, _, _), Sent, Stream) :-
	format(Stream, '% ~w. ', [Sent]),
	print_pros(Pros, Stream),
	nl(Stream),
	nl(Stream).
print_pros(hyp(_,_,Pros), Stream) :-
	format(Stream, '~w ', [Pros]).
print_pros(leaf(_,_,Pros,_,_), Stream) :-
	format(Stream, '~w ', [Pros]).
print_pros(p(_,_,_,L,R), Stream) :-
	print_pros(L, Stream),
	print_pros(R, Stream).

reduce_pros(hyp(_,_,Pros), Pros).
reduce_pros(leaf(_,_,Pros,_,_), Pros).
reduce_pros(p(I,_,_,L0,R0), p(I,L,R)) :-
	reduce_pros(L0, L),
	reduce_pros(R0, R).

gui :-
	repeat,
	/* start main loop, tell Tk we are in the INIT state, that is done processing the
	   previous command and waiting for new input */
	format('INIT~nREPEAT~n', []),
	flush_output,
	read(Input),
	format('TREATING INPUT: ~w~n', [Input]),
	start(Input),
	Input = end_of_file,
	!.

extended_active(Active) :-
	state(S, L),
	extended_active(S, L, Active).

start(end_of_file) :-
	!,
	halt.
start(trace) :-
	!,
	trace.
start(undo(Input)) :-
	!,
	state(choose_active, [Active0, N0]),
	active(Input, Item),
	format('UNDO: ~w~n', [Item]),
	flush_output,
	justification(Item, Justification),
	Justification =.. [_Rulename,I|Indices0],
	sort([I|Indices0], Indices),
	format('JUST: ~w~n', [Indices]),
	flush_output,
	ord_select(Item, Active0, Active1),
	ord_union(Active1, Indices, Active),
	retractall(stored(Item, _, _, _, _, _)),
	format('~nCHOOSE ACTIVE~n', []),
	write_active(Active),
	flush_output,
	update_state(Active, N0).
start(active(Input)) :-
	!,
	state_active(Active0, N0),
	active(Input, Item),
	handle(Item, Active0, Active, N0, N),
	update_state(Active, N).
start(choose(Input)) :-
	!,
	state(choose_rule, [[C|Cs],_,A0,N0]),
	integer(Input),
	nth0(Input, [C|Cs], _-(Item-Just)),
	apply_rule(Item, Just, A0, A, N0, N),
	format('~nCHOOSE ACTIVE~n', []),
	write_active(A),
	flush_output,
	update_state(A, N).
start(load(File)) :-
	!,
	format('COMPILING~n', []),
	flush_output,
	compile(File),
	format('DONE~n', []),
	findall(Number, clause(sent(Number, _), _), List0),
	sort(List0, List),
	format('SENTENCES~n', []),
	write_list(List),
	flush_output,
	List = [First|_],
	interactive_parse_init(First).
	
start(parse(Number)) :-
	!,
	interactive_parse_init(Number).
start(X) :-
	format('STRANGE INPUT: ~w~n', [X]).


state_active(Active, N) :-
	state(choose_active, [Active, N]),
	!.
% This case is relevant is case the user cancels the rule selection
state_active(Active, N) :-
	state(choose_rule, [_,A,Active0,N]),
	ord_insert(Active0, A, Active).

interactive_parse_init(Number) :-
	clause(sent(Number, Sem), prob_parse(List, Sem)),
	!,
	format('START INITIALIZATION ~w~n', [List]),
	flush_output,
	update_crossing(Number),
	check_log_stream,
	init_chart,
	empty_heap(Heap),
	format('HEAP ~w~n', [Heap]),
	flush_output,
	list_to_chart(List, 0, Heap, As, [], 0, _V, _SemInfo, []),
	format('START AXIOMS ~w~n', [As]),
	flush_output,
	add_axioms_to_chart(As, 0, N, Active),
	format('START PARSE ~w~n', [Number]),
	flush_output,
	interactive_parse_tk(Active, N).
interactive_parse_init(Number) :-
	format('No clause found for sent(~k, Sem)~n', [Number]).

% = interactive_parse_tk(+ActiveItems, +MaxChart)

interactive_parse_tk(Active, N) :-
	/* send choices to Tk, then wait for Tk user input */
	format('~nCHOOSE ACTIVE~n', []),
	write_active(Active),
	flush_output,
	update_state(Active, N).

% = handle(+Item, +ActiveIn, -ActiveOut, +NewIn, -NewOut)
%
% Find all consequences of Item (in the context of active items
% ActiveIn) and update the chart accordingly.
%
% Do nothing if no consequences are found, ask for user input
% if multiple consequences are found and if only a single
% consequence exists (nearly always possible with careful
% selection of active items) apply it immediately.

handle(X, A0, A, N0, N) :-
	ord_select(X, A0, A1),
	!,
	find_all_consequences1(X, Cs0, A0),
    (
        Cs0 = [C|Cs1]
    ->
        handle_consequences(Cs1, C, X, A1, A, N0, N)
    ;
        format('REDO~n', []),
        flush_output,
        fail
    ).

% = handle_consequence(+OtherConsequences, +FirstConsequence, Agenda, New)
%
% 

handle_consequences([], C, _, A0, A, N0, N) :-
	C = _-(Item-Just),
	apply_rule(Item, Just, A0, A, N0, N),
	!,
	format('~nCHOOSE ACTIVE~n', []),
	write_active(A),
	flush_output.
handle_consequences(Cs, C, X, A0, _A, N0, _N) :-
	format('CHOOSE RULE~n', []),
	write_choice([C|Cs]),
	flush_output,
	retractall(state(_,_)),
	assert(state(choose_rule,[[C|Cs],X,A0,N0])),
	fail.

% = update_state(+ActiveFormulas, +ChartNew)
%
% Updates the permanent state with the current ordered set of ActiveFormulas
% and the first unused chart position ChartNew
%
% If a solution is found, compute the corresponding proof and output this proof
% to the Prolog, LaTeX and XML files.

update_state(Active, N) :-
	retractall(state(_,_)),
   (
        Active = [I],
    	check_solution(Sem)
   ->
	format('~nSOLUTION~n~w~n', [Sem]),
        compute_proof(I)
   ;
        true
   ),
	assert(state(choose_active, [Active, N])).       


write_list([]) :-
	format('LIST END~n', []),
	flush_output.
write_list([C|Cs]) :-
	format('~w~n', [C]),
	write_list(Cs).

write_choice([]) :-
	format('LIST END~n', []),
	flush_output.	
write_choice([_-(_-Just)|Cs]) :-
	Just =.. [Rule,P|Prems],
	format('~w ', [Rule]),
	write_prems(Prems,P),
	write_choice(Cs).

write_prems([], P) :-
	active(C, P),
	format('~w~n', [C]).
write_prems([P|Ps], P0) :-
	active(C, P0),
	format('~w ', [C]),
	write_prems(Ps, P).

write_active(L0) :-
	retractall(active(_,_)),
	order_active(L0, [], L),
	write_active1(L, 0).

order_active([], S, S).
order_active([C|Cs], S0, S) :-
	stored(C, _, L, R, F0, data(Pros0, Sem, W, L1, L2, L3)),
	tcl_pros(Pros0, Pros),
	tcl_form(F0, F),
	tcl_stacks(L1, L2, L3, Stacks),
	ord_key_insert(S0, L, t(C,R,F,Pros,Sem,W,Stacks), S1),
	order_active(Cs, S1, S).

write_active1([], _) :-
	format('LIST END~n', []),
	flush_output.
write_active1([L-t(C,R,F,Pros,Sem,W,Stacks)|Cs], N0) :-
	format('~w ~w ~w ~w ~w ~w ~w ~w~n', [C, L, R, F, Pros, Sem, W, Stacks]),
	assert(active(N0,C)),
	N is N0 + 1,
	write_active1(Cs, N).

tcl_stacks([], [], [], ' ') :-
	!.
tcl_stacks([t(_I,_J,F0,_Sem)], [], [], F) :-
	!,
	tcl_form(F0, F).
tcl_stacks([], [_-t(F0,_,_)], [], F) :-
	!,
	tcl_form(F0, F).
tcl_stacks([], [], [_-t(F0,_,_)], F) :-
	!,
	tcl_form(F0, F).
tcl_stacks(As, Bs, Cs, As-Bs-Cs).

tcl_form(F0, F) :-
	macro_expand(F0, F1),
	tcl_form1(F1, F).

tcl_form1(lit(np(A,_,_)), N) :-
	!,
     (
        A == nom
    ->
        N = np_nom
    ;
        A == acc
    ->
        N = np_acc
     ;
        N = np
     ).
tcl_form1(lit(s(T)), S) :-
	!,
    (
        T == main
    ->
        S = s_main       
    ;
        T == pass
    ->
        S = s_pass       
    ;
        T == ppart
    ->
        S = s_ppart       
    ;
        T == ppres
    ->
        S = s_ppres       
    ;
        T == q
    ->
        S = s_q
    ;
        T == whq
    ->
        S = s_whq
    ;
        T == inf
    ->
        S = s_inf
    ;
        T == ainf
    ->
        S = s_ainf
    ;
        T == deinf
    ->
        S = s_deinf
    ;
        S = s
    ).
tcl_form1(lit(pp_a), PP) :-
	!,
	PP = pp_à.
tcl_form1(pp_a, PP) :-
	!,
	PP = pp_à.
tcl_form1(lit(pp_de), PP) :-
	!,
	PP = pp_de.
tcl_form1(lit(pp_par), PP) :-
	!,
	PP = pp_par.
tcl_form1(lit(pp(P)), PP) :-
	!,
    (
        var(P)
    ->
        PP = pp
    ;
        P = a
    ->
        PP = pp_à
    ;
        atom(P)
    ->
        atomic_list_concat([pp,P], '_', PP)
    ;
       PP = pp
    ).
tcl_form1(lit(F), F).
tcl_form1(dr(I,A0,B0), dr(I,A,B)) :-
	tcl_form1(A0, A),
	tcl_form1(B0, B).
tcl_form1(dl(I,A0,B0), dl(I,A,B)) :-
	tcl_form1(A0, A),
	tcl_form1(B0, B).
tcl_form1(p(I,A0,B0), p(I,A,B)) :-
	tcl_form1(A0, A),
	tcl_form1(B0, B).
tcl_form1(dia(I,A0), dia(I,A)) :-
	tcl_form1(A0, A).
tcl_form1(box(I,A0), box(I,A)) :-
	tcl_form1(A0, A).

tcl_pros(',', '*COMMA*') :-
	!.
tcl_pros('(', '*LPAR*') :-
	!.
tcl_pros(')', '*RPAR*') :-
	!.
tcl_pros(p(I,A0,B0), p(I,A,B)) :-
	!,
	tcl_pros(A0, A),
	tcl_pros(B0, B).
tcl_pros(P, P).

flatten_pros(p(_,A,B)) -->
	!,
	flatten_pros(A),
	[' '],
	flatten_pros(B).
flatten_pros(dia(_,A)) -->
	!,
	flatten_pros(A).
flatten_pros(A) -->
	[A].
